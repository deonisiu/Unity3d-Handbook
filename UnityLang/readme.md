# Справочник по C#

## Полезные ссылки

* [Сайт о программировании Metanit.com](https://metanit.com/sharp/)
* [Руководство по C# Microsoft](https://docs.microsoft.com/ru-ru/dotnet/csharp/index)
* [Видео уроки Metanit](https://www.youtube.com/playlist?list=PLL-k0Ff5RfqXGhAooRkUpzMLd6_Fpr13I)

## Особенности C#

### Примитивные типы данных

* ***bool*** (true | false) - **System.Boolean**
* ***byte*** (цеслое число от 0 до 255) - 1 байт **System.Byte**
* ***sbyte*** (целое число от -128 до 127) - 1 байт **System.SByte**
* ***short*** (целое число от -32768 до 32767) - 2 байта **System.Int16**
* ***ushort*** (целое число от 0 до 65535) - 2 байта **System.UInt16**
* ***int*** (целые числа по умолчанию -2147483648 до 2147483647) 4 байта **System.Int32**
* ***uint*** (от 0 до 4294967295U) 4 байта **System.UInt32**
* ***long*** (от -9 223 372 036 854 775 808L до 9 223 372 036 854 775 807L ) 8 байт **System.Int64**
* ***ulong*** (от 0 до 18 446 744 073 709 551 615UL) 8 байт **System.UInt64**
* ***float*** (числа с плавающей точкой от -3.4\*10в38f до 3.4\*10в38f) 4 байта **System.Single**
* ***double*** (числа с плавающей точкой от 5.0\*10в-324 до 1.7\*10в308) 8 байт **System.Double**
* ***decimal*** (десятичное дробное число, если без запятой то от 0 до +/–79 228 162 514 264 337 593 543 950 335m; если с запятой, то от 0 до +/–7,9228162514264337593543950335M с 28 разрядами после) 16 байт **System.Decimal**
* ***char*** (хранит одиночный символ Unicode) 2 байта **System.Char**
* ***string*** (хранит набор символов Unicode) **System.String**
* ***object*** (значение любого типа данных) 4 байта на х32 и 8 байт на х64 **System.Object**(базовый для всех других типов и классов .NET)

### Неявная типизация
Вместо названия типа данных используется ключевое слово **var**. Компилятор сам выводит тип данных исходя из присвоенного значения.
``` C#
var hello = "Hell to World"; // hello = string
var c = 20; // c = int
```

### Преобразования типов данных
Преобразования могут быть:
1. сужающие(narrowing)
2. расширяющие(widering)  
Расширяющие преобразования расширяют размер объекта в памяти и наоборот.

Компилятор может проводить неявные преобразования в след. случаях:
byte -> short -> int -> long -> decimal  
int -> double  
short -> float -> double  
char -> int  
В остальных случаях необходимо использовать явное преобразование:
``` C#
int x = (int)numb;
float y = (float)numb;
byte c = (byte)(a+b);
```

## Массивы

### Стандартный массив

``` C#
int[] numbers; // массив целых чисел
int[] nums  = new int[4]; // задаем массиву размерность в 4 элемента
// Также мы сразу можем указать значения для элементов
int[] nums2 = new int[] { 1, 2, 3, 5 };
```

### Перебор массивов. Цикл foreach
``` C#
foreach (тип_данных название_переменной in контейнер)
{
    // действия
}
```
Например:
``` C#
int[] numbers = new int[] { 1, 2, 3, 4, 5 };
foreach (int i in numbers)
{
    Console.WriteLine(i);
}
```

### Многомерные массивы
Двухмерный массив:  
`int[,] nums2 = { { 0, 1, 2 }, { 3, 4, 5 } };`

Трехмерный массив:  
`int[,,] nums3 = new int[2, 3, 4];`

Способы определения двухмерных массивов:
``` C#
int[,] nums1;
int[,] nums2 = new int[2, 3];
int[,] nums3 = new int[2, 3] { { 0, 1, 2 }, { 3, 4, 5 } };
int[,] nums4 = new int[,] { { 0, 1, 2 }, { 3, 4, 5 } };
int[,] nums5 = new [,]{ { 0, 1, 2 }, { 3, 4, 5 } };
int[,] nums6 = { { 0, 1, 2 }, { 3, 4, 5 } };
```

Перебор двухмерного массива:  
``` C#
int[,] mas = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 }, { 10, 11, 12 } };
 
int rows = mas.GetUpperBound(0) + 1;
int columns = mas.Length / rows;
 
for (int i = 0; i < rows; i++)
{
    for (int j = 0; j < columns; j++)
    {
        Console.Write($"{mas[i, j]} \t");
    }
    Console.WriteLine();
}
```

### Массив массивов
От многомерных массивов надо отличать массив массивов или так называемый "зубчатый массив":
``` C#
int[][] nums = new int[3][];
nums[0] = new int[2] { 1, 2 };          // выделяем память для первого подмассива
nums[1] = new int[3] { 1, 2, 3 };       // выделяем память для второго подмассива
nums[2] = new int[5] { 1, 2, 3, 4, 5 }; // выделяем память для третьего подмассива
```

## Функции

### Общий вид
Общее определение методов выглядит следующим образом:
``` C#
[модификаторы] тип_возвращаемого_значения название_метода ([параметры])
{
    // тело метода
}
```

### Параметры функций
Передача параметров может быть *по значению* и *по ссылке*:
1. По значению : `void func(int a, float b);`
2. По ссылке : `void func(ref int a, ref float b);`

При передаче по ссылке используется ключевое слово ***ref*** перед типом параметра.

### Модификатор out
Параметры в C# могут быть также выходными. Чтобы сделать параметр выходным перед ним ставится модификатор out:
``` C#
static void Sum(int x, int y, out int a)
{
    a = x + y;
}
Sum(x, 15, out z);
```
* Причем, как и в случае с ref ключевое слово out используется как при определении метода, так и при его вызове.  
* Также обратите внимание, что методы, использующие такие параметры, обязательно должны присваивать им определенное значение!
``` C#
static void Sum(int x, int y, out int a)
{
    a = //... а обязательно должно быть чему то равно 
}
```

### Необязательные параметры
С# позволяет использовать необязательные параметры. 
* Для таких параметров необходимо объявить значение по умолчанию
* После необязательных параметров все последующие параметры также должны быть необязательными
``` C#
static int OptionalParam(int x, int y, int z=5, int s=4)
{
    return x + y + z + s;
}
OptionalParam(2, 3); // Всего 2 входных параметра z=5 s=4
OptionalParam(2, 3, 10); // 3 входных параметра z=10 s=4
```

### Именованные параметры
При вызове методов значения для параметров передаются в порядке их объявления в методе. Но мы можем нарушить подобный порядок, используя именованные параметры:
``` C#
static int OptionalParam(int x, int y, int z=5, int s=4)
{
    return x + y + z + s;
}
static void Main(string[] args)
{
    OptionalParam(x:2, y:3);
     
    //Необязательный параметр z использует значение по умолчанию
    OptionalParam(y:2,x:3,s:10);
 
    Console.ReadLine();
}
```

### Массив параметров params
Используя ключевое слово *params*, мы можем передавать неопределенное количество параметров:
``` C#
static void Addition(params int[] integers)
{
    int result = 0;
    for (int i = 0; i < integers.Length; i++)
    {
        result += integers[i];
    }
    Console.WriteLine(result);
}

Addition(1, 2, 3, 4, 5);
 
int[] array = new int[] { 1, 2, 3, 4 };
Addition(array);

Addition();

```
Причем на место параметра с модификатором *params* мы можем передать как отдельные значения, так и массив значений, либо вообще не передавать параметры.
* **Важно!** Массив параметров *params* нужно всегда указывать последним!

### Перечисления enum
В C# есть такой тип данных как **enum** или перечисление. Представляет из себя набор логически связанных констант. 
* Перечисление обязательно должно представлять целочисленный тип (byte, int, short, long)
* Если тип не указан, используется int.
``` C#
enum Days // неявный тип int
{
    Monday, // По умолчанию первый элемент = 0
    Tuesday, // Каждый следующий увеличивается на 1
    Wednesday, // 2
    Thursday, // 3
    Friday, // 4
    Saturday, // 5
    Sunday // 6
}
  
enum Time : byte // явный тип byte
{
    Morning = 3, // Мы можем явно указать первый
    Afternoon, // 4
    Evening, // 5
    Night // 6
}

enum Operation // неявный тип int
{ 
    Add = 2, // Либо задать значения каждого элемента явным образом
    Subtract = 4,
    Multiply = 8,
    Divide = 16
}
```

* Каждое перечисление фактически определяет новый тип данных.
* Мы можем определить переменную этого типа и использовать ее
``` C#
enum Operation // неявный тип int
{ 
    Add = 2,
    Subtract = 4,
    Multiply = 8,
    Divide = 16
}
Operation op;
op = Operation.Add;
```
* Несмотря на то, что каждая константа сопоставляется с определенным числом, мы не можем присвоить ей числовое значение.
* И также если мы будем выводить на консоль значение этой переменной, то мы получим имя константы, а не числовое значение.

Применение перечисления на примере:
``` C#
class Program
{
    enum Operation
    {
        Add = 1,
        Subtract,
        Multiply,
        Divide
    }
 
    static void MathOp(double x, double y, Operation op)
    {
        double result = 0.0;
 
        switch (op)
        {
            case Operation.Add:
                result = x + y;
                break;
            case Operation.Subtract:
                result = x - y;
                break;
            case Operation.Multiply:
                result = x * y;
                break;
            case Operation.Divide:
                result = x / y;
                break;
        }
 
        Console.WriteLine("Результат операции равен {0}", result);
    }
 
    static void Main(string[] args)
    {
        // Тип операции задаем с помощью константы Operation.Add, которая равна 1
        MathOp(10, 5, Operation.Add);
        // Тип операции задаем с помощью константы Operation.Multiply, которая равна 3
        MathOp(11, 5, Operation.Multiply);
             
        Console.ReadLine();
    }  
}
```

### Структуры struct
В C# имеется и составной тип данных, который называется структурой. Структуры могут содержать в себе обычные переменные и методы:
``` C#
struct Book
{
    public string name;
    public string author;
    public int year;
 
    public void Info()
    {
        Console.WriteLine($"Книга '{name}' (автор {author}) была издана в {year} году");
    }
}
```
* Может содержать конструктор для инициализации начальных значений переменных:  
``` C#
Book book2 = new Book(); // использование конструктора
```
Вызов конструктора имеет следующий синтаксис: `new название_структуры ([список_параметров])`

### Кортежи (работа с набором значений)
Кортеж представляет набор значений, заключенных в круглые скобки:
``` C#
var tuple = (5, 10);
```
* Кортеж tuple имеет два значения: 5 и 10. Мы можем обращаться к ним через Item[n]:
``` C#
tuple.Item1 += 25;
tuple.Item2 = 10 + tuple.Item1;
```
* Для переменных кортежа можно указывать явный тип переменных:
``` C#
(int, int) tuple = (5, 10);
(string, int, double) person = ("Tom", 25, 81.23);
```
* Мы также можем дать названия полям кортежа:
``` C#
var tuple = (count:5, sum:10);
Console.WriteLine(tuple.count); // 5
Console.WriteLine(tuple.sum); // 10
```
* Мы даже можем не использовать переменную для определения всего кортежа, а использовать отдельные переменные для его полей:
``` C#
var (name, age) = ("Tom", 23);
Console.WriteLine(name);    // Tom
Console.WriteLine(age);     // 23
```

* Кортежи можно использовть для возвращения из функций более одного значения:
``` C#
private static (int, int) GetValues()
{
    var result = (1, 3);
    return result;
}
```
* И также кортеж может передаваться в качестве параметра в метод:
``` C#
private static (string name, int age) GetTuple((string n, int a) tuple, int x)
{
    var result = (name: tuple.n, age: tuple.a + x);
    return result;
}
var (name, age) = GetTuple(("Tom", 23), 12);
```

## Обработка исключений
Язык C# предоставляет разработчикам возможности для обработки исключений с помощью конструкции **try...catch...finally**. 
* При возникновении исключения среда CLR ищет блок catch, который может обработать данное исключение. 
* Далее в любом случае выполняется блок finally, но его использовать не обязательно.
``` C#
try
{
    a[5] = 4; // тут возникнет исключение, так как у нас в массиве только 4 элемента
    Console.WriteLine("Завершение блока try");
}
catch (Exception ex)
{
    Console.WriteLine("Ошибка: " + ex.Message);
}
finally
{
    Console.WriteLine("Блок finally");
}
```

### Обработка нескольких исключений
При необходимости мы можем разграничить обработку различных типов исключений, включив дополнительные блоки catch:
``` C#
static void Main(string[] args)
{
try
{
    //...
}
catch (FileNotFoundException e)
{
    // Обработка исключения, возникшего при отсутствии файла
}
catch (IOException e)
{
    // Обработка исключений ввода-вывода
}
Console.ReadLine();
}
```

### Оператор throw
C помощью throw мы сами можем создать исключение и вызвать его в процессе выполнения.
``` C#
try
{
    string message = Console.ReadLine();
    if (message.Length > 6)
    {
        throw new Exception("Длина строки больше 6 символов");
    }
}
catch (Exception e)
{
    Console.WriteLine("Ошибка: " + e.Message);
}
```

### Фильтры исключений
Фильтры позволяют обрабатывать исключения в зависимости от определенных условий:
``` C#
try
{
    int result = x / y;
}
catch(Exception ex) when (y==0)
{
    Console.WriteLine("y не должен быть равен 0");
}
catch(Exception ex)
{
    Console.WriteLine(ex.Message);
}
```

### Переменные-ссылки и возвращение ссылки


``` C#

```